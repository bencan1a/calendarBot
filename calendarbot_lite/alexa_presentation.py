"""Presentation layer for Alexa responses - separates business logic from SSML formatting.

This module provides a clean separation between business logic (data gathering) and
presentation logic (formatting responses for Alexa). The Protocol-based interface
allows for easy testing and addition of new output formats.
"""

from __future__ import annotations

import datetime
import logging
from typing import TYPE_CHECKING, Any, Optional, Protocol

if TYPE_CHECKING:
    from .alexa_types import AlexaDoneForDayInfo

logger = logging.getLogger(__name__)


class AlexaPresenter(Protocol):
    """Protocol defining the interface for Alexa response presenters.

    Presenters are responsible for formatting data into speech-ready responses,
    either as plain text or SSML. This separation allows business logic to focus
    on data gathering while presenters handle formatting.
    """

    def format_next_meeting(self, meeting_data: Optional[dict[str, Any]]) -> tuple[str, Optional[str]]:
        """Format next meeting data into speech and optional SSML.

        Args:
            meeting_data: Dictionary with meeting info (subject, seconds_until_start, etc.)
                         or None if no meeting found

        Returns:
            Tuple of (speech_text, optional_ssml)
        """
        ...

    def format_time_until(
        self, seconds_until: int, meeting_data: Optional[dict[str, Any]]
    ) -> tuple[str, Optional[str]]:
        """Format time until next meeting into speech and optional SSML.

        Args:
            seconds_until: Seconds until next meeting (0 if no meeting)
            meeting_data: Optional meeting data dictionary

        Returns:
            Tuple of (speech_text, optional_ssml)
        """
        ...

    def format_done_for_day(
        self, has_meetings_today: bool, speech_text: str
    ) -> tuple[str, Optional[str]]:
        """Format done-for-day response into speech and optional SSML.

        Args:
            has_meetings_today: Whether user has meetings today
            speech_text: Pre-generated speech text

        Returns:
            Tuple of (speech_text, optional_ssml)
        """
        ...

    def format_launch_summary(
        self,
        done_info: AlexaDoneForDayInfo,
        primary_meeting: Optional[dict[str, Any]],
        tz: Any = None,
        request_tz: Optional[str] = None,
        now: Optional[datetime.datetime] = None,
    ) -> tuple[str, Optional[str]]:
        """Format launch summary into speech and optional SSML.

        Args:
            done_info: Done-for-day information
            primary_meeting: Primary meeting to highlight or None
            tz: Timezone object for formatting times (optional)
            request_tz: Original timezone string from request (optional)
            now: Current datetime for time comparisons (optional)

        Returns:
            Tuple of (speech_text, optional_ssml)
        """
        ...

    def format_morning_summary(self, summary_result: Any) -> tuple[str, Optional[str]]:
        """Format morning summary into speech and optional SSML.

        Args:
            summary_result: MorningSummaryResult object

        Returns:
            Tuple of (speech_text, optional_ssml)
        """
        ...


class PlainTextPresenter:
    """Plain text presenter that generates speech without SSML.

    This presenter is useful for testing, debugging, and scenarios where
    SSML is not required or supported.
    """

    def format_next_meeting(self, meeting_data: Optional[dict[str, Any]]) -> tuple[str, Optional[str]]:
        """Format next meeting as plain text."""
        if not meeting_data:
            return "You have no upcoming meetings.", None

        subject = meeting_data.get("subject", "Unknown")
        duration_spoken = meeting_data.get("duration_spoken", "")
        return f"Your next meeting is {subject} {duration_spoken}.", None

    def format_time_until(
        self, seconds_until: int, meeting_data: Optional[dict[str, Any]]
    ) -> tuple[str, Optional[str]]:
        """Format time until as plain text."""
        if not meeting_data or seconds_until == 0:
            return "You have no upcoming meetings.", None

        duration_spoken = meeting_data.get("duration_spoken", "")
        return f"Your next meeting is {duration_spoken}.", None

    def format_done_for_day(
        self, has_meetings_today: bool, speech_text: str
    ) -> tuple[str, Optional[str]]:
        """Format done-for-day as plain text."""
        # Speech text is already generated by business logic
        return speech_text, None

    def format_launch_summary(
        self,
        done_info: AlexaDoneForDayInfo,
        primary_meeting: Optional[dict[str, Any]],
        tz: Any = None,
        request_tz: Optional[str] = None,
        now: Optional[datetime.datetime] = None,
    ) -> tuple[str, Optional[str]]:
        """Format launch summary as plain text with full speech generation.

        This method generates the complete speech text including done-for-day information.
        """
        # Generate speech based on whether user has meetings today
        if done_info["has_meetings_today"]:
            speech_text = self._format_has_meetings_speech(
                primary_meeting, done_info, tz, request_tz, now
            )
        else:
            speech_text = self._format_no_meetings_speech(primary_meeting)

        return speech_text, None

    def _format_has_meetings_speech(
        self,
        next_meeting: Optional[dict[str, Any]],
        done_info: AlexaDoneForDayInfo,
        tz: Any,
        request_tz: Optional[str],
        now: Optional[datetime.datetime],
    ) -> str:
        """Generate speech for when user has meetings today."""
        if next_meeting:
            speech_text = f"Your next meeting is {next_meeting['subject']} {next_meeting['duration_spoken']}."
        else:
            speech_text = "You have no more meetings today."

        # Add done-for-day information
        if done_info["last_meeting_end_iso"] and tz and now:
            speech_text += self._format_end_time(
                done_info["last_meeting_end_iso"], tz, request_tz, now
            )

        return speech_text

    def _format_no_meetings_speech(self, future_meeting: Optional[dict[str, Any]]) -> str:
        """Generate speech for when user has no meetings today."""
        if future_meeting:
            return f"No meetings today, you're free until {future_meeting['subject']} {future_meeting['duration_spoken']}."
        return "No meetings today. You have no upcoming meetings scheduled."

    def _format_end_time(
        self,
        end_iso: str,
        tz: Any,
        request_tz: Optional[str],
        now: datetime.datetime,
    ) -> str:
        """Format end time for speech text."""
        try:
            end_utc = datetime.datetime.fromisoformat(end_iso.replace("Z", "+00:00"))

            # Convert to local time for speech
            end_local = end_utc.astimezone(tz)

            # Format time string (show UTC if no timezone provided)
            if request_tz:
                time_str = end_local.strftime("%-I:%M %p").lower()
            else:
                time_str = end_local.strftime("%-I:%M %p UTC").lower()

            if now >= end_utc:
                return " You're all done for today!"
            return f" You'll be done for the day at {time_str}."

        except (ValueError, AttributeError) as e:
            logger.warning("Error formatting end time for launch summary: %s", e)
            return " I couldn't determine when your last meeting ends today."
        except Exception as e:
            logger.error("Unexpected error formatting end time: %s", e, exc_info=True)
            return " I couldn't determine when your last meeting ends today."

    def format_morning_summary(self, summary_result: Any) -> tuple[str, Optional[str]]:
        """Format morning summary as plain text."""
        return summary_result.speech_text, None


class SSMLPresenter:
    """SSML presenter that generates enhanced speech with SSML markup.

    This presenter wraps existing SSML renderers and provides a unified
    interface for SSML generation across all Alexa handlers.
    """

    def __init__(self, ssml_renderers: Optional[dict[str, Any]] = None):
        """Initialize SSML presenter.

        Args:
            ssml_renderers: Dictionary mapping renderer names to callables:
                - "meeting": Renderer for meeting data
                - "time_until": Renderer for time until data
                - "done_for_day": Renderer for done-for-day data
                - "morning_summary": Renderer for morning summary data
        """
        self.renderers = ssml_renderers or {}
        self.plain_text_fallback = PlainTextPresenter()

    def format_next_meeting(self, meeting_data: Optional[dict[str, Any]]) -> tuple[str, Optional[str]]:
        """Format next meeting with SSML if available."""
        # Generate plain text first
        speech_text, _ = self.plain_text_fallback.format_next_meeting(meeting_data)

        # Try to generate SSML
        ssml_output = None
        if "meeting" in self.renderers and meeting_data:
            try:
                ssml_output = self.renderers["meeting"](meeting_data)
                if ssml_output:
                    logger.info("Next meeting SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Next meeting SSML generation failed: %s", e, exc_info=True)

        return speech_text, ssml_output

    def format_time_until(
        self, seconds_until: int, meeting_data: Optional[dict[str, Any]]
    ) -> tuple[str, Optional[str]]:
        """Format time until with SSML if available."""
        # Generate plain text first
        speech_text, _ = self.plain_text_fallback.format_time_until(seconds_until, meeting_data)

        # Try to generate SSML
        ssml_output = None
        if "time_until" in self.renderers:
            try:
                ssml_output = self.renderers["time_until"](seconds_until, meeting_data)
                if ssml_output:
                    logger.info("Time until SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Time until SSML generation failed: %s", e, exc_info=True)

        return speech_text, ssml_output

    def format_done_for_day(
        self, has_meetings_today: bool, speech_text: str
    ) -> tuple[str, Optional[str]]:
        """Format done-for-day with SSML if available."""
        # Try to generate SSML
        ssml_output = None
        if "done_for_day" in self.renderers:
            try:
                ssml_output = self.renderers["done_for_day"](has_meetings_today, speech_text)
                if ssml_output:
                    logger.info("Done-for-day SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Done-for-day SSML generation failed: %s", e, exc_info=True)

        return speech_text, ssml_output

    def format_launch_summary(
        self,
        done_info: AlexaDoneForDayInfo,
        primary_meeting: Optional[dict[str, Any]],
        tz: Any = None,
        request_tz: Optional[str] = None,
        now: Optional[datetime.datetime] = None,
    ) -> tuple[str, Optional[str]]:
        """Format launch summary with SSML if available.

        This uses either the meeting renderer (if meetings today) or done-for-day
        renderer (if no meetings today).
        """
        # Generate plain text fallback with full parameters
        speech_text, _ = self.plain_text_fallback.format_launch_summary(
            done_info, primary_meeting, tz, request_tz, now
        )

        # Try to generate SSML based on scenario
        ssml_output = None
        if (
            done_info["has_meetings_today"]
            and primary_meeting
            and "meeting" in self.renderers
        ):
            # Meetings today - use meeting SSML
            try:
                event = primary_meeting["event"]
                meeting_data = {
                    "subject": primary_meeting["subject"],
                    "seconds_until_start": primary_meeting["seconds_until"],
                    "duration_spoken": primary_meeting["duration_spoken"],
                    "location": event.location.display_name if event.location else "",
                    "is_online_meeting": event.is_online_meeting,
                }
                ssml_output = self.renderers["meeting"](meeting_data)
                if ssml_output:
                    logger.info("Launch summary (meetings) SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Launch summary (meetings) SSML generation failed: %s", e, exc_info=True)
        elif "done_for_day" in self.renderers:
            # No meetings today - use done-for-day SSML
            try:
                ssml_output = self.renderers["done_for_day"](
                    done_info["has_meetings_today"], speech_text
                )
                if ssml_output:
                    logger.info("Launch summary (no meetings) SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Launch summary (no meetings) SSML generation failed: %s", e, exc_info=True)

        return speech_text, ssml_output

    def format_morning_summary(self, summary_result: Any) -> tuple[str, Optional[str]]:
        """Format morning summary with SSML if available."""
        speech_text = summary_result.speech_text

        # Try to generate SSML
        ssml_output = None
        if "morning_summary" in self.renderers:
            try:
                ssml_output = self.renderers["morning_summary"](summary_result)
                if ssml_output:
                    logger.info("Morning summary SSML generated: %d characters", len(ssml_output))
            except Exception as e:
                logger.error("Morning summary SSML generation failed: %s", e, exc_info=True)

        return speech_text, ssml_output
